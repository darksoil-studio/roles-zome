// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/runner/work/roles-zome/roles-zome/docs/public/backend/release/build/tx5-go-pion-sys-33f3ab52b51bd89a/out/main.go:1:1
package main

/*
#include <stdint.h>
#include <stdlib.h>

static inline uintptr_t void_star_to_ptr_t(void *ptr) {
  return (uintptr_t)ptr;
}

static inline void *ptr_to_void_star(uintptr_t ptr) {
  return (void *)ptr;
}

typedef void (*MessageCb) (
  void *usr,
  uintptr_t message_type,
  uintptr_t slot_a,
  uintptr_t slot_b,
  uintptr_t slot_c,
  uintptr_t slot_d
);

static inline void MessageCbInvoke(
  MessageCb cb,
  void *usr,
  uintptr_t message_type,
  uintptr_t slot_a,
  uintptr_t slot_b,
  uintptr_t slot_c,
  uintptr_t slot_d
) {
  cb(usr, message_type, slot_a, slot_b, slot_c, slot_d);
}
*/
import _ "unsafe"

import (
	"bytes"
	"encoding/json"
	"fmt"
	"sync"
	"unsafe"

	"runtime/debug"

	"github.com/pion/logging"
	"github.com/pion/webrtc/v3"
)

type UintPtrT =  /*line :51:17*/_Ctype_uintptr_t /*line :51:28*/
type MessageCb =  /*line :52:18*/_Ctype_MessageCb /*line :52:29*/

func VoidStarToPtrT(v unsafe.Pointer) UintPtrT {
	return func() _Ctype_uintptr_t{ _cgo0 := /*line :55:30*/v; _cgoCheckPointer(_cgo0, nil); return /*line :55:32*/_Cfunc_void_star_to_ptr_t(_cgo0); }()
}

func PtrToVoidStar(ptr UintPtrT) unsafe.Pointer {
	return ( /*line :59:9*/_Cfunc_ptr_to_void_star /*line :59:26*/)(ptr)
}

func PtrToCharStar(ptr UintPtrT) *byte {
	return (*byte)(( /*line :63:17*/_Cfunc_ptr_to_void_star /*line :63:34*/)(ptr))
}

func LoadBytesSafe(ptr UintPtrT, length UintPtrT) *bytes.Buffer {
	raw := unsafe.Slice(PtrToCharStar(ptr), length)

	buf := new(bytes.Buffer)
	buf.Grow(len(raw))
	buf.Write(raw)
	return buf
}

type customLogger struct{}

func (c customLogger) Trace(msg string) {
	EmitTrace(LvlTrace, msg)
}
func (c customLogger) Tracef(format string, args ...interface{}) {
	c.Trace(fmt.Sprintf(format, args...))
}
func (c customLogger) Debug(msg string) {
	EmitTrace(LvlDebug, msg)
}
func (c customLogger) Debugf(format string, args ...interface{}) {
	c.Debug(fmt.Sprintf(format, args...))
}
func (c customLogger) Info(msg string) {
	EmitTrace(LvlInfo, msg)
}
func (c customLogger) Infof(format string, args ...interface{}) {
	c.Info(fmt.Sprintf(format, args...))
}
func (c customLogger) Warn(msg string) {
	EmitTrace(LvlWarn, msg)
}
func (c customLogger) Warnf(format string, args ...interface{}) {
	c.Warn(fmt.Sprintf(format, args...))
}
func (c customLogger) Error(msg string) {
	EmitTrace(LvlError, msg)
}
func (c customLogger) Errorf(format string, args ...interface{}) {
	c.Error(fmt.Sprintf(format, args...))
}

type customLoggerFactory struct{}

func (c customLoggerFactory) NewLogger(subsystem string) logging.LeveledLogger {
	return customLogger{}
}

var webrtcApiMu sync.Mutex
var webrtcApi *webrtc.API

func setWebrtcApi(api *webrtc.API) {
	if api == nil {
		panic("CannotSetWebrtcApiToNil")
	}
	webrtcApiMu.Lock()
	defer webrtcApiMu.Unlock()
	if webrtcApi != nil {
		panic("CannotSetWebrtcApiMultipleTimes")
	}
	webrtcApi = api
}

func getWebrtcApi() *webrtc.API {
	webrtcApiMu.Lock()
	defer webrtcApiMu.Unlock()
	if webrtcApi == nil {
		panic("WebrtcApiIsUnset:CallTx5Init")
	}
	return webrtcApi
}

func MessageCbInvoke(
	cb MessageCb,
	usr unsafe.Pointer,
	message_type UintPtrT,
	slot_a UintPtrT,
	slot_b UintPtrT,
	slot_c UintPtrT,
	slot_d UintPtrT,
) {
	func() { var _cgo0 *[0]byte = /*line :147:20*/cb; _cgo1 := /*line :147:24*/usr; var _cgo2 _Ctype_uintptr_t = /*line :147:29*/message_type; var _cgo3 _Ctype_uintptr_t = /*line :147:43*/slot_a; var _cgo4 _Ctype_uintptr_t = /*line :147:51*/slot_b; var _cgo5 _Ctype_uintptr_t = /*line :147:59*/slot_c; var _cgo6 _Ctype_uintptr_t = /*line :147:67*/slot_d; _cgoCheckPointer(_cgo1, nil); /*line :147:74*/_Cfunc_MessageCbInvoke(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
}

type eventReg struct {
	mu        sync.Mutex
	event_cb   /*line :152:12*/_Ctype_MessageCb /*line :152:23*/
	event_usr unsafe.Pointer
}

var globalEventReg eventReg

func EmitEvent(
	message_type UintPtrT,
	slot_a UintPtrT,
	slot_b UintPtrT,
	slot_c UintPtrT,
	slot_d UintPtrT,
) {
	globalEventReg.mu.Lock()
	defer globalEventReg.mu.Unlock()

	if globalEventReg.event_cb == nil {
		// TODO!!! MEMORY LEAK
		// if there is not an event handler
		// we need to clean up (Free) any types in this event
		// that have handles, such as DataChannels and Buffers
		return
	}

	func() { var _cgo0 *[0]byte = /*line :177:3*/globalEventReg.event_cb; _cgo1 := /*line :178:3*/globalEventReg.event_usr; var _cgo2 _Ctype_uintptr_t = /*line :179:3*/message_type; var _cgo3 _Ctype_uintptr_t = /*line :180:3*/slot_a; var _cgo4 _Ctype_uintptr_t = /*line :181:3*/slot_b; var _cgo5 _Ctype_uintptr_t = /*line :182:3*/slot_c; var _cgo6 _Ctype_uintptr_t = /*line :183:3*/slot_d; _cgoCheckPointer(_cgo1, nil); /*line :184:3*/_Cfunc_MessageCbInvoke(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
}

type Tx5InitConfig struct {
	EphemeralUdpPortMin *uint16 `json:"ephemeralUdpPortMin,omitempty"`
	EphemeralUdpPortMax *uint16 `json:"ephemeralUdpPortMax,omitempty"`
}

// Initialize the library with some optional configuration.
// You MUST call this exactly ONCE before opening any peer connections.
func CallTx5Init(
	config_buf_id UintPtrT,
	response_cb MessageCb,
	response_usr unsafe.Pointer,
) {
	buf := BufferFromPtr(config_buf_id)
	buf.mu.Lock()
	defer buf.mu.Unlock()

	if buf.closed {
		panic("BufferClosed")
	}

	var tmpConfig Tx5InitConfig
	if err := json.Unmarshal(buf.buf.Bytes(), &tmpConfig); err != nil {
		errStr := fmt.Sprintf("%s: %s", err, buf.buf.Bytes())
		panic(errStr)
	}

	setting_engine := webrtc.SettingEngine{
		LoggerFactory: customLoggerFactory{},
	}

	var port_min uint16 = 1
	var port_max uint16 = 65535

	if tmpConfig.EphemeralUdpPortMin != nil {
		port_min = *tmpConfig.EphemeralUdpPortMin
	}

	if tmpConfig.EphemeralUdpPortMax != nil {
		port_max = *tmpConfig.EphemeralUdpPortMax
	}

	setting_engine.SetEphemeralUDPPortRange(port_min, port_max)

	setWebrtcApi(webrtc.NewAPI(webrtc.WithSettingEngine(setting_engine)))

	MessageCbInvoke(
		response_cb,
		response_usr,
		TyTx5Init,
		0,
		0,
		0,
		0,
	)
}

// register the MessageCb that will be invoked for events
//
//export OnEvent
func OnEvent(
	// the callback to invoke
	event_cb  /*line :248:11*/_Ctype_MessageCb /*line :248:22*/,

	// the user data to forward to the callback
	event_usr unsafe.Pointer,
) unsafe.Pointer {
	globalEventReg.mu.Lock()
	defer globalEventReg.mu.Unlock()

	prev := globalEventReg.event_usr

	globalEventReg.event_cb = event_cb
	globalEventReg.event_usr = event_usr

	return prev
}

const (
	LvlTrace UintPtrT = 0x01
	LvlDebug UintPtrT = 0x02
	LvlInfo  UintPtrT = 0x03
	LvlWarn  UintPtrT = 0x04
	LvlError UintPtrT = 0x05
)

func EmitTrace(
	lvl UintPtrT,
	msg string,
) {
	buf := []byte(msg)

	EmitEvent(
		TyOnTrace,
		lvl,
		func() _Ctype_uintptr_t{ _cgoIndex0 := &/*line :281:40*/buf; _cgo0 := /*line :281:24*/unsafe.Pointer(&(*_cgoIndex0)[0]); _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :281:48*/_Cfunc_void_star_to_ptr_t(_cgo0); }(),
		UintPtrT(len(buf)),
		0,
	)
}

// make a call into the library
//
//export Call
func Call(
	// call type indicator
	call_type UintPtrT,

	// input params
	slot_a UintPtrT,
	slot_b UintPtrT,
	slot_c UintPtrT,
	slot_d UintPtrT,

	// immediate result callback / response to this call
	// this will always be invoked. nil will panic
	response_cb  /*line :302:14*/_Ctype_MessageCb /*line :302:25*/,

	// the user data to forward to the result callback
	response_usr unsafe.Pointer,
) {
	// on panics, return error text
	defer func() {
		if err := recover(); err != nil {
			if response_cb == nil {
				return
			}

			bytes := ([]byte)(fmt.Sprintf("%s %s", err, string(debug.Stack())))
			func() { var _cgo0 *[0]byte = /*line :316:5*/response_cb; _cgo1 := /*line :317:5*/response_usr; var _cgo2 _Ctype_uintptr_t = /*line :318:5*/TyErr; var _cgo3 _Ctype_uintptr_t = func() _Ctype_uintptr_t{ _cgoIndex0 := /*line :320:42*/([]byte)("Error"); _cgo0 := /*line :320:26*/unsafe.Pointer(&_cgoIndex0[0]); _cgoCheckPointer(_cgo0, _cgoIndex0); return /*line :320:64*/_Cfunc_void_star_to_ptr_t(_cgo0); }(); var _cgo4 _Ctype_uintptr_t = /*line :322:5*/UintPtrT(5); var _cgo5 _Ctype_uintptr_t = func() _Ctype_uintptr_t{ _cgoIndex0 := &/*line :324:42*/bytes; _cgo0 := /*line :324:26*/unsafe.Pointer(&(*_cgoIndex0)[0]); _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :324:52*/_Cfunc_void_star_to_ptr_t(_cgo0); }(); var _cgo6 _Ctype_uintptr_t = /*line :326:5*/UintPtrT(len(bytes)); _cgoCheckPointer(_cgo1, nil); /*line :327:5*/_Cfunc_MessageCbInvoke(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
		}
	}()

	// now that our panic handler is set up, delegate to callInner
	callInner(call_type, slot_a, slot_b, slot_c, slot_d, response_cb, response_usr)
}

func callInner(
	// call type indicator
	call_type UintPtrT,

	// input params
	slot_a UintPtrT,
	slot_b UintPtrT,
	slot_c UintPtrT,
	slot_d UintPtrT,

	// immediate result callback / response to this call
	// this will always be invoked. nil will panic
	response_cb  /*line :347:14*/_Ctype_MessageCb /*line :347:25*/,

	// the user data to forward to the result callback
	response_usr unsafe.Pointer,
) {
	// -- these calls can be made even if there is no callback pointer -- //

	switch call_type {
	case TyBufferFree:
		CallBufferFree(slot_a)
		return
	case TyPeerConFree:
		CallPeerConFree(slot_a)
		return
	case TyDataChanFree:
		CallDataChanFree(slot_a)
		return
	}

	// -- the remaining calls require response_cb to be non-nil -- //

	if response_cb == nil {
		panic(fmt.Errorf("response_cb cannot be nil for call_type: %d", call_type))
	}

	switch call_type {
	case TyTx5Init:
		CallTx5Init(slot_a, response_cb, response_usr)
	case TyBufferAlloc:
		CallBufferAlloc(response_cb, response_usr)
	case TyBufferAccess:
		CallBufferAccess(slot_a, response_cb, response_usr)
	case TyBufferReserve:
		CallBufferReserve(slot_a, slot_b, response_cb, response_usr)
	case TyBufferExtend:
		CallBufferExtend(slot_a, slot_b, slot_c, response_cb, response_usr)
	case TyBufferRead:
		CallBufferRead(slot_a, slot_b, response_cb, response_usr)
	case TyPeerConAlloc:
		CallPeerConAlloc(slot_a, response_cb, response_usr)
	case TyPeerConStats:
		CallPeerConStats(slot_a, response_cb, response_usr)
	case TyPeerConCreateOffer:
		CallPeerConCreateOffer(slot_a, slot_b, response_cb, response_usr)
	case TyPeerConCreateAnswer:
		CallPeerConCreateAnswer(slot_a, slot_b, response_cb, response_usr)
	case TyPeerConSetLocalDesc:
		CallPeerConSetLocalDesc(slot_a, slot_b, response_cb, response_usr)
	case TyPeerConSetRemDesc:
		CallPeerConSetRemDesc(slot_a, slot_b, response_cb, response_usr)
	case TyPeerConAddICECandidate:
		CallPeerConAddICECandidate(slot_a, slot_b, response_cb, response_usr)
	case TyPeerConCreateDataChan:
		CallPeerConCreateDataChan(slot_a, slot_b, response_cb, response_usr)
	case TyDataChanLabel:
		CallDataChanLabel(slot_a, response_cb, response_usr)
	case TyDataChanReadyState:
		CallDataChanReadyState(slot_a, response_cb, response_usr)
	case TyDataChanSend:
		CallDataChanSend(slot_a, slot_b, response_cb, response_usr)
	case TyDataChanSetBufferedAmountLowThreshold:
		CallDataChanSetBufferedAmountLowThreshold(slot_a, slot_b, response_cb, response_usr)
	case TyDataChanBufferedAmount:
		CallDataChanBufferedAmount(slot_a, response_cb, response_usr)
	default:
		panic(fmt.Errorf("invalid call_type: %d", call_type))
	}
}

func main() {}
